var fs = require("fs");
var JSON = require("../package.json");
var beauty = require("js-beautify").js_beautify;
var compiler = require("./compiler");
var path = require("path");

var run_cmd = function(cmd, args, callBack) {
	var spawn = require('child_process').spawn;
	var child = spawn(cmd, args);
	var resp = "";

	child.stdout.on('data', function(buffer) {
		resp += buffer.toString()
	});

	child.stdout.on('end', function() {
		callBack(resp)
	});
};

var main = function() {
	var options = {
		execute: false,
		compile: true,
		std: true,
		help: false,
		version: false,
		strict: false,
		ast: false,
		repl: false
	};

	var args = [];

	for (arg in process.argv.slice(2)) {
		if (process.argv.slice(2)[arg] == "-v" || process.argv.slice(2)[arg] == "--version") {
			options.version = true;
		} else if (process.argv.slice(2)[arg] == "-e" || process.argv.slice(2)[arg] == "--version") {
			options.execute = true;
		} else if (process.argv.slice(2)[arg] == "-h" || process.argv.slice(2)[arg] == "--help") {
			options.help = true;
		} else if (process.argv.slice(2)[arg] == "-ns" || process.argv.slice(2)[arg] == "--no-std") {
			options.std = false;
		} else if (process.argv.slice(2)[arg] == "-s" || process.argv.slice(2)[arg] == "--strict") {
			options.strict = true;
		} else if (process.argv.slice(2)[arg] == "-r" || process.argv.slice(2)[arg] == "--repl") {
			options.repl = true;
		} else if (process.argv.slice(2)[arg] == "-ast" || process.argv.slice(2)[arg] == "--tokens") {
			options.ast = true;
			options.std = false;
			options.strict = false;
		}

		if (process.argv.slice(2)[arg][0] != '-') {
			args.push(process.argv.slice(2)[arg]);
		}
	}

	if (options.std) {
		options.strict = true;
	}

	if (options.version) {
		console.log("Stripes v" + JSON.version);
		return;
	}

	if (options.repl) {
		require("./repl.js");
		return;
	}

	if (options.help) {
		console.log("Stripes v" + JSON.version);
		console.log("\n	$ stripes [args] <file>");
		console.log("\nArguments:");
		console.log("\n	-v, --version		Shows version");
		console.log("	-h, --help		Shows help");
		console.log("	-e, --execute		Executes compiled file");
		console.log("	-s, --strict		Enables strict mode");
		console.log("	-ns, --no-std		Disables standard library");
		console.log("	-ast, --tokens		Shows tokens instead of compiling");
		console.log("\nExample:");
		console.log("\n	$ stripes -e test.stps");
		return;
	}

	var code = "";
	var prelude = fs.readFileSync(path.dirname(__dirname) + '/lib/prelude.stps',
		'utf8');

	if (args[0] == undefined) {
		throw "No file specified as first argument.";
	}

	args.pop();

	var loc = args.join(" ").trim();

	var target = loc;
	var equals = false;

	if (loc.indexOf('=') !== -1) {
		if (args.join(" ").trim().indexOf("C:") != 0) {
			loc = (process.cwd() + "/" + args.join(" ").trim()).split('=')[0].trim();
			target = process.cwd() + "/" + args.join("").trim().split('=')[1].trim();
		} else {
			loc = loc.split('=')[0].trim();
			target = args.join("").trim().split('=')[1].trim();
		}
	} else {
		if (args.join(" ").trim().indexOf("C:") != 0) {
			loc = process.cwd() + "/" + args.join(" ").trim();
			target = process.cwd() + "/" + args.join(" ").trim();
		}
	}

	code += fs.readFileSync(loc);

	if (target.endsWith(".stps")) {
		target = target.replace(".stps", ".js");
	} else if (target.endsWith(".son")) {
		options.strict = false;
		target = target.replace(".son", ".json");
	} else if (target.endsWith(".sast")) {
		options.std = false;
		target = target.replace(".sast", ".js");
	} else if (target.endsWith(".litstps")) {
		options.std = false;
		target = target.replace(".litstps", ".js");
	}

	if (options.ast) {
		console.log(compiler.getAST(code));
		return;
	}

	var output;

	if (options.std && !loc.endsWith(".sast")) {
		output = "/* Generated by Stripes v" + JSON.version + " */\n" +
			compiler.GenerateStripes(prelude + code);
	} else if (!loc.endsWith(".sast") && !loc.endsWith(".litstps")) {
		output = "/* Generated by Stripes v" + JSON.version + " */\n" +
			compiler.GenerateStripes(code)
	}

	if (loc.endsWith(".son")) {
		output = compiler.GenerateStripes(code);
	}

	if (loc.endsWith(".sast")) {
		output = "/* Generated by Stripes v" + JSON.version + " */\n" +
			compiler.Generate(eval(code));
	}

	if (options.strict) {
		if (loc.endsWith(".son")) {
			output = compiler.GenerateStripes(code);
		} else if (loc.endsWith(".sast")) {
			output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
				compiler.Generate(eval(code));
		} else if (loc.endsWith(".litstps")) {
			if (options.std) {
				var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
				var matches = [], found;

				while (found = reg.exec(code)) {
				  matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
				}

				output = "/* Generated by Stripes v" + JSON.version + " */\n" +
					compiler.GenerateStripes(matches.join(""));
			} else {
				var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
				var matches = [], found;

				while (found = reg.exec(code)) {
				  matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
				}

				output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
					compiler.GenerateStripes(prelude + matches.join(""));
			}
		} else {
			if (options.std) {
				output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
					compiler.GenerateStripes(prelude + code);
			} else {
				output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
					compiler.GenerateStripes(code);
			}
		}
	} else {
		if (loc.endsWith(".litstps")) {
			if (options.std) {
				var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
				var matches = [], found;

				while (found = reg.exec(code)) {
				  matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
				}

				output = "/* Generated by Stripes v" + JSON.version + " */\n" +
					compiler.GenerateStripes(prelude + matches.join(""));
			} else {
				var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
				var matches = [], found;

				while (found = reg.exec(code)) {
				  matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
				}

				output = "/* Generated by Stripes v" + JSON.version + " */\n" +
					compiler.Generate(GenerateStripes.join(""));
			}
		}
	}

	var generated = beauty(
		output, {
			indent_size: 2
		});

	fs.writeFile(target, generated,
		function(err) {
			if (err) {
				console.log(err);
				return;
			} else {
				if (!options.execute) {
					console.log("[Stripes] " + loc + " -> " + target);
				}
			}
		});

	fs.writeFileSync(target, generated);

	if (options.execute) {
		run_cmd("node", [target], function(text) {
			console.log("\n" + text);
		});
	}
};

String.prototype.endsWith = function(suffix) {
	return this.indexOf(suffix, this.length - suffix.length) !== -1;
};


main();
